@using Blazor.Extensions.Canvas.Canvas2D
@using Blazor.Extensions
@using System.Text.Json
@using IdleBattler_Common.Models.Arena
@implements IDisposable

<h3>Arena</h3>

<BECanvas Width="400" Height="400" @ref="_canvasReference"></BECanvas>

<style>
    canvas {
        border: thin solid black;
    }
</style>

@code {
    private Canvas2DContext _context;

    private readonly PeriodicTimer _timer = new(TimeSpan.FromMilliseconds(10));

    protected BECanvasComponent _canvasReference;

    protected override async Task OnInitializedAsync()
    {
        var movements = await GetRandomMovements();

        await RunOnTimer(this._timer, () => Draw(this._context, this._canvasReference, movements));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        this._context = await this._canvasReference.CreateCanvas2DAsync();
    }

    public void Dispose() {
        this._context.Dispose(); 
    }

    private async Task DrawBall(double xLoc, double yLoc, Canvas2DContext context) {
        await context.BeginPathAsync();
        await context.ArcAsync(xLoc, yLoc, 10, 0, Math.PI * 2);
        await context.SetFillStyleAsync("red");
        await context.FillAsync();
        await context.ClosePathAsync();
    }

    private async Task Draw(Canvas2DContext context, BECanvasComponent canvas, MovementModel movements) {
        if (context == null || canvas == null) return;
        await context.ClearRectAsync(0, 0, canvas.Width, canvas.Height);

        foreach (var fighterMovement in movements.Movements)
        {
            var location = fighterMovement.Locations.First();
            // Don't remove the final position of the fighter
            if (fighterMovement.Locations.Count > 1) fighterMovement.Locations.RemoveAt(0);
            double xLocation = canvas.Width * (location.XLocation / 100.0); // Server returns a "percentage" location that we can use to draw a location based on canvas size
            double yLocation = canvas.Height * (location.YLocation / 100.0);
            await DrawBall(xLocation, yLocation, context);
        }
    }

    private async Task RunOnTimer(PeriodicTimer timer, Func<Task> function) {
        try {
            while (await timer.WaitForNextTickAsync())
            {
                await function();
            }
        }
        catch (Exception ex) {
        }
    }

    private async Task<MovementModel> GetRandomMovements() 
    {
        var client = new HttpClient();

        var arenaGuid = Guid.NewGuid();
        var streamTask = await client.GetStreamAsync($"https://localhost:7156/api/arenamovement/{arenaGuid.ToString()}/{arenaGuid.ToString()}");
        try {
            return JsonSerializer.Deserialize<MovementModel>(streamTask);
        } 
        catch (Exception ex) 
        {
            return null;
        }
    }

    private async Task<MovementModel> GetMovementsFromLocation(int xLocation, int yLocation)
    {
        var client = new HttpClient();

        var arenaGuid = Guid.NewGuid();
        var streamTask = await client.GetStreamAsync($"https://localhost:7156/api/arenamovement/{arenaGuid.ToString()}/{arenaGuid.ToString()}?initialX={xLocation}&initialY={yLocation}");
        try
        {
            return JsonSerializer.Deserialize<MovementModel>(streamTask);
        }
        catch (Exception ex)
        {
            return null;
        }
    }
}
